[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Daniel Geiszler",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nMaking Rolling Blog Posts\n\n\n\n\n\n\nprogramming\n\n\ncontinuous integration\n\n\n\n\n\n\n\n\n\nDec 21, 2024\n\n\n1 min\n\n\n\n\n\n\n\nMachine Learning Basics\n\n\n\n\n\n\nmachine learning\n\n\n\n\n\n\n\n\n\nDec 19, 2024\n\n\n1 min\n\n\n\n\n\n\n\nLearning Pyro for Better Content Sorting\n\n\n\n\n\n\nmachine learning\n\n\npython\n\n\n\n\n\n\n\n\n\nDec 15, 2024\n\n\n10 min\n\n\n\n\n\n\n\nInteresting Etymologies Running List\n\n\n\n\n\n\nlinguistics\n\n\n\n\n\n\n\n\n\nMay 16, 2024\n\n\n1 min\n\n\n\n\n\n\n\nGetting Around Istanbul\n\n\n\n\n\n\nIstanbul\n\n\nTurkey\n\n\npublic transit\n\n\n\n\n\n\n\n\n\nJul 19, 2023\n\n\n6 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/20230719-getting-around-istanbul/index.html",
    "href": "posts/20230719-getting-around-istanbul/index.html",
    "title": "Getting Around Istanbul",
    "section": "",
    "text": "Summary:\n\nThe metro and ferries are the best public transit options\nGoogle Maps works, but Moovit has much better coverage for ferry routes\nAvoid relying on taxis unless absolutely necessary\nUber calls taxis and you will likely have an excessive wait\nAvoid minibuses (light blue buses on Google Maps)\n\nIf you don’t like my guide, you can read more about getting to and from the airport here\nIf you don’t like my guide, you can read more about public transit here\n\n\nGeneral Information\nIstanbul has a very well-developed public transit system. It spans the Bosphorous Strait to connect both sides of city and connects both passenger airports (IST and SAW) to the city center. Public transit, especially the ferries and metro, are the best way to get around the city due to rush hour traffic. The metro system covers all of the main touristic areas of the city and is easy to use. On weeknights most public transit shuts down around midnight, so plan on staying near your hotel if you want to go out late. Google Maps does a good job of providing routes and even has several privately owned airport bus companies listed. Almost all of the public transit can be accessed using an IstanbulKart that can be purchased from and reloaded at yellow kiosks in metro stations. In tourist areas, you’re more likely to find kiosks that have an English option. Each connection you use will incur a new charge, so make sure your IstanbulKart is loaded up. And importantly, most IstanbulKart machines cannot take bills larger than 100 TL! Each leg of a journey will probably cost ~10TL\n\n\nModes of Transit\n\nMetro\n\n\n\nIstanbul metro map\n\n\nThe metro system in Istanbul is clean and easy to use. It functions just like the metro lines in most major cities. Expect trains every 5-10 min in most cases. Trains run from 6:00 AM to midnight, but there is uninterrupted 24-hour service with trains every 30 min Friday and Saturday night. This should be one of your primary ways of getting around the city. There is only one metro line that crosses the Bosphorous Strait, the Marmaray (gray line). This line is more expensive.\n\n\nFerries\nFerries in Istanbul are fully integrated into the public transit network, so you can use your IstanbulKart to board them. They are very convenient, and should also be one of your primary modes of transportation. They are automatically included in Google Maps routes and marked with a blue boat sign. At many of the ferry stations, there will be several wharfs with different ferries. For the busiest ferries, there can even be two docks running the same route at staggered intervals. Make sure you are getting on the right one by checking the signs! Public ferry schedules can be found here: https://sehirhatlari.istanbul/en/timetables . There are also private ferries (which can still be accessed using your IstanbulKart), but these are not included in Google Maps. Roughly half of the ferries moving on major routes are operated by private companies. If you see a ferry on Google Maps that’s running on the :00 and :30 marks, there is probably another dock nearby with a private ferry that leaves on the :15 and :45 marks. Private ferries are included in the Moovit app.\n\n\nBuses\nThere are three types of buses in Istanbul that might be included in your route.\n\nStandard city buses: These are big yellow and black buses, and they have a yellow bus symbol on Google Maps. You pay when you get on. Most buses will stop running before midnight.\nMetrobuses: These have a beige bus symbol on Google Maps. These buses have their own lanes and move pretty quickly. You pay when you enter the station as if it were a metro.\nMinibuses: These are tiny death traps with no ventilation. They are marked with a light blue bus symbol on Google Maps. I recommend not using them because they only take cash and you have to tell them your destination.\n\n\n\nTaxis\nAvoid taxis unless absolutely necessary. They are notorious for scamming people, often do not speak English, and will not know how to get to your destination. Many taxis are cash only. If you have to take a taxi, make sure the meter is running as soon as you get in the cab, and pull up the route on your phone so that you see if they make any detours. There may be additional fees associated with crossing the bridges, but these should be small (~20 TL).\n\n\nGetting to/from the Airport\nBoth Istanbul airports (IST and SAW) are a ways outside the city, so it can take some time to get to the city center where your hotels probably are.\nThere are several ways you can get to/from the airport. The easiest way is going to be getting your hotel to call you an airport shuttle. Note that the wedding venue (A11 Hotel Bosphorus) provides an airport shuttle. You also might be able to save yourself a few dollars by booking a shuttle yourself with a private shuttle service such as https://airporttransfer.vip/ . This should cost ~€40. I’ve seen good reviews for this service, but I haven’t used it personally. Driving directly to your hotel should take ~45 min, but traffic can add up to an hour if you’re landing during rush hour.\nAnother way is to take an airport bus. There are private companies that offer reliable service between the airport and popular destinations in Istanbul. These run 24/7, but at 30-60 min intervals. The most popular is Havaist, which leaves from the -2 floor of the IST airport https://istanbul-international-airport.com/transportation/bus/ . If you are staying in Uskudar, you can take the Havaist bus to Kadikoy, followed by the metro from Kadikoy to Uskudar. This is two stops, but requires changing lines at the first stop. The total cost of this trip will be ~$7, not including buying an IstanbulKart to use the public transit. You can also take the Havaist bus to Besiktas and take a ferry from Besiktas to Uskudar.\nThe airports also connects directly to the metro system. You can connect to either the historic areas of Istanbul or Uskudar, but it will require several transfers, and take slightly longer than the Havaist bus. You can get to Uskudar by taking the M11-M7-M2-Marmaray route. Most other areas of the city—such as Galata and Eminonu—are accessible via the M2 line without crossing the Bosphorous using the Marmaray. Some of the stations are quite large, and it may not be desirable to lug around a ton of bags."
  },
  {
    "objectID": "posts/20241219-machine-learning-basics/machine_learning_basics.html",
    "href": "posts/20241219-machine-learning-basics/machine_learning_basics.html",
    "title": "Daniel Geiszler",
    "section": "",
    "text": "This is a running list of machine learning architectures, terms, and concepts. I write them down here for quick reference in the future. If you see an issue, please let me know! ## Types of Learning Supervised learning: training a model on labeled pairs of input and output data to learn how to predict the output from the input\nUnsupervised learning: using unlabeled data to find patterns or clusters without having predefined labels\nSemi-supervised learning: training a model using partially labeled data, where the unlabeled data can either have labels inferred or inform the model about clusters, decision boundaries, or other properties\nOnline learning: training a model as data arrives rather than all at once, efficiently using space and allowing the model to adapt to changes over tome\nFederated learning: a distributed approach to training models where models are trained separately on different devices or datasets before being pooled\nReinforcement learning: training a model that acts as an agent and is rewarded when working properly towards a goal and punishment when not\nSelf-supervised learning: learning where the model generates its own labels from artificially constructed data\nTransfer learning: adapting a model made for one task to a new task without additional training\nFine-tuning: a type of transfer learning involving adapting a model that was previously trained on one dataset for a new purpose, training it on a smaller subset of domain-specific data, reducing the amount of time and data required to build a model"
  },
  {
    "objectID": "posts/20241219-machine-learning-basics/machine_learning_basics.html#decision-trees",
    "href": "posts/20241219-machine-learning-basics/machine_learning_basics.html#decision-trees",
    "title": "Daniel Geiszler",
    "section": "Decision Trees",
    "text": "Decision Trees\nDecision trees segregate data based on rules until a stopping condition is met, usually that subgroups are pure or a maximum depth is reached. Trees can predict categorical data (classification trees) and numerical data (regression trees). Advantages include fast predictions, intelligibility, and low compute requirements. Disadvantages include being prone to overfitting and instability (i.e., adding more data can cause the entire tree to be reconstructed).\nBranches are decided based on splitting criteria. Examples of splitting criteria include:\nGini impurity: measure how frequently a randomly chosen entry would be mislabeled based on the branch rule\nInformation gain: compared the entropy before and after splitting to see how much information is gained after the split\nMean squared error (regression trees): rules are chosen minimize variance in predicted values\nTrees can be “regularized” via pruning to prevent overfitting. This can happen in two ways:\nPre-pruning (early stopping): preventing new branches from being formed after a certain threshold or depth\nPost-pruning (cost-complexity pruning): post-box removal of branches that don’t produce any gains in validation data\n\nRandom Forests\nRandom forests solve a single decision tree’s problem with overfitting by producing an ensemble of decision trees. Decision trees are fit for random subsets of the data, then averaged (regression) or vote on the outcome (classification) during prediction. The process of averaging trees that are trained in parallel is called “bagging”.\n\n\nBoosted Trees\nBoosted trees compensate for the weakness of an initial tree by building sequential trees to correct errors in previous trees. The process of averaging trees that are trained sequentially is called boosting. Some key algorithms related to boosting:\nAdaBoost: increases the weight of incorrectly predicted data in subsequent trees\nGradient boosting: a specific type of boosting where a differentiable loss function is used to fit sequential models on the residuals of the previous model\nXGBoost: a popular library implementing gradient-boosted decision trees that is optimized for efficiency"
  },
  {
    "objectID": "posts/20241219-machine-learning-basics/machine_learning_basics.html#regularization",
    "href": "posts/20241219-machine-learning-basics/machine_learning_basics.html#regularization",
    "title": "Daniel Geiszler",
    "section": "Regularization",
    "text": "Regularization\nRegularization is the process by which we penalize model complexity, done to reduce overfitting and make models more generalizable. This can be split into two broad categories, explicit regularization—where a regularizing term, be it a penalty, prior, or constraint, is added to directly the optimization problem, and implicit regularization, which broadly encompasses other methods of preventing overfitting.\nThese are some of the most commonly types of explicit regularization:\nLasso (L1 regularization): adds a penalty proportional to the absolute values of the model parameters, making some parameters go to zero (get dropped out) during optimization. It can be used to perform feature selection if you suspect there are irrelevant variables.\nRidge regression (L2 regularization): adds a penalty proportional to the sum of squares of the model parameters, shrinking their coefficients to zero but generally without dropping them out of the optimization altogether. It can be used to reduce the weights of highly correlated variables in tandem, whereas L1 regularization might select a single feature and drop the others. It is generally more stable than L1 regularization because it doesn’t remove parameters.\nElastic Net: combines L1 and L2 regularization, simultaneously shrinking coefficients while performing feature selection. The relative weight of the L1 and L2 contributions to regularization are controlled by the \\(\\alpha\\) parameter.\n\nDeep Learning\nDeep learning uses multi-layer neural networks to learn representations from data. Each layer is made up of neurons which activate under simple activation functions. Differences in deep learning modalities can arise from differences in activation functions or neuron connectivity."
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html",
    "href": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html",
    "title": "Daniel Geiszler",
    "section": "",
    "text": "Sometimes I stumble across something while reading and I want to be able to write and post it somewhere so that I’ll be able to access it later, but that isn’t meaningful enough to make a blog post about on its own. With this setup, I can just take a note on my phone and automatically update my blog. To do this, I use a combination of Obsidian (a notes app on my phone), Quarto (the publishing system for my personal website), and Github Actions for automatic deployment. The end result is that I can take a note on my phone in markdown format and have it automatically pushed and rendered on my website in my blog.\nThe basic workflow here is to make changes on your device in the Obsidian app, push those changes to your (private) notes repository, copy the file containing those changes to your website repository, and render them.\nYou need three things to do this: 1. The Obsidian app with the Github plugin 2. A Github repository to host your Obsidian notes (it can be private so that you can make notes without others seeing them) 3. A github repository with a Quarto project"
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html#step-1-setting-up-obsidian",
    "href": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html#step-1-setting-up-obsidian",
    "title": "Daniel Geiszler",
    "section": "Step 1: Setting up Obsidian",
    "text": "Step 1: Setting up Obsidian\n\nDownload the Obsidian app from your mobile store\nInside Obsidian, download the Git Community plugin\nOn Github, create a Personal Access Token linked to your account. This token will need to have read/write privileges for your repository, so the “repo” box needs to be checked when setting up your token. SAVE THIS TOKEN FOR LATER.\nConfigure your Git plugin inside Obsidian to use your username, email, and your new Personal Access Token.\nLink your notes repository on Github to your Obsidian app.\n\nNow, any time you make changes to your files, you can go to the bottom right hamburger menu &gt; Open command palette &gt; Git: to commit and push your changes to your Git repository. (Note: for these commands to appear, you need to be in read mode rather than write mode, which can be toggled by clicking the book/pencil in the top right corner.)"
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html#step-2-setting-up-your-rolling-blog-post",
    "href": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html#step-2-setting-up-your-rolling-blog-post",
    "title": "Daniel Geiszler",
    "section": "Step 2: Setting up your rolling blog post",
    "text": "Step 2: Setting up your rolling blog post\n\nIn Obsidian, create a new file, then commit your changes and push the file to your repository. 2. Verify that your file appears in your github repository after pushing. It should be a markdown file with the name {name}.md. I’m using a post title machine_learning_basics to do this, which appears as machine_learning_basics.md in my repository. If it’s there, everything is working!\nIn your Quarto site, create a new blog post. I have mine set up to have my blog posts contained inside individual directories (see my example here. To set up a new blog post, I created the folder 20241219-machine-learning-basics. Inside that folder, create the file index.qmd with the following contents (without the backslah to escape to include command}:\n\n---\ntitle: \"Machine Learning Basics\"\nauthor: \"Daniel Geiszler\"\ndate: \"2024-12-19\"\ncategories: [machine learning]\n---\n\n\\{{&lt; include machine_learning_basics.md &gt;}}\nThe first few lines are metadata for the blog post. The following statement populated the rendered blog post with the contents of another markdown file. Eventually, this markdown file will exist and be populated by your post’s content, but for now we can forget about it. However, if you want to preview your site using quarto preview to make sure it’s working, you’ll need to create an empty markdown file with the above file name in this directory."
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html#step-3-set-up-github-actions-to-automatically-push-changes-to-your-website-repository",
    "href": "posts/20241221-rolling-blog-posts/rolling_blog_posts.html#step-3-set-up-github-actions-to-automatically-push-changes-to-your-website-repository",
    "title": "Daniel Geiszler",
    "section": "Step 3: Set up Github actions to automatically push changes to your website repository",
    "text": "Step 3: Set up Github actions to automatically push changes to your website repository\n\nGo back to your Obsidian repository and add a repository secret. This prevents your personal access token allowing read/write access from being public and is a must for security purposes. Inside your repository, go to Settings &gt; Secrets and variables, then under Secrets add your personal access token from before as a new repository secret with the name PERSONAL_ACCESS_TOKEN.\ncreate a folder called .github/workflows if it doesn’t already exist. You may need to pull these changes to your Obsidian app before pushing any subsequent changes on your device.\nCreate a new yaml file titled something like “sync_blogpost.yml” with the following contents. You’ll need to change the fields marked with comments to match your fields. (Note: The inline comments change from # to // because some are yaml comments and some are javascript comments.)\n\nname: Sync Machine Learning Basics File # Change this to the name of your workflow\n\non:\n  push:\n    paths:\n      - 'machine_learning_basics.md'  # Watch for changes in this specific file in your notes repo\n\njobs:\n  update-file:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout source repo\n      uses: actions/checkout@v3\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16'\n\n    - name: Fetch SHA and Update File\n      uses: actions/github-script@v6\n      with:\n        github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        script: |\n          const fs = require('fs');\n          const path = require('path');\n          const filePath = path.join(process.env.GITHUB_WORKSPACE, 'machine_learning_basics.md'); // Change this to the name of your blog post's file\n          const content = fs.readFileSync(filePath, 'utf8');\n          const encodedContent = Buffer.from(content).toString('base64');\n\n          // Fetch the current SHA of the file to be updated\n          const response = await github.rest.repos.getContent({\n            owner: 'danielgeiszler', // Change this to your github username\n            repo: 'personalwebsite', // Change this to your website's repository\n            path: 'posts/20241219-machine-learning-basics/machine_learning_basics.md', // Change this to the path inside your website repository\n            ref: 'main'  // Make sure to use the correct branch here\n          });\n\n          const sha = response.data.sha;\n\n          // Update the file with the new content and the current SHA\n          const updateResponse = await github.rest.repos.createOrUpdateFileContents({\n            owner: 'danielgeiszler', // Change this to your github username\n            repo: 'personalwebsite', // Change this to your website's repository\n            path: 'posts/20241219-machine-learning-basics/machine_learning_basics.md', // Change this to the path inside your website repository\n            message: 'Update machine learning basics', // Change this to the message displayed for your action\n            content: encodedContent,\n            sha: sha,  // Provide the SHA fetched from the previous step\n            branch: 'main',  // Make sure this is the correct branch\n            committer: {\n              name: process.env.GITHUB_ACTOR,\n              email: `${process.env.GITHUB_ACTOR}@users.noreply.github.com`\n            },\n            author: {\n              name: process.env.GITHUB_ACTOR,\n              email: `${process.env.GITHUB_ACTOR}@users.noreply.github.com`\n            }\n          });\n\n          console.log(\"File updated\", updateResponse.data);\nThat’s it! Now you can write notes on your phone and have them automatically added to your blog post."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/etymologies.html",
    "href": "posts/20240517-interesting-etymologies/etymologies.html",
    "title": "Daniel Geiszler",
    "section": "",
    "text": "This is a running list of etymologies that I think are neat."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/etymologies.html#temujin",
    "href": "posts/20240517-interesting-etymologies/etymologies.html#temujin",
    "title": "Daniel Geiszler",
    "section": "Temujin",
    "text": "Temujin\nGenghis Khan was just a title; his real name was Temujin. Temujin is a Mongolic name that was probably borrowed from the Proto-Turkic *temürči meaning “blacksmith”. The -ci suffix denotes a person who works with something, in this case *temür, or iron. Modern Turkish’s “demirci”, also meaning “blacksmith”, is a descendent of this word and a cognate to Temujin. These names and their friends were and are still common throughout the region. For example, Timur (also known as Tamerlame), of the Timurid Empire, shares the same root—Timur, like Turkish demir, means iron."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/etymologies.html#ordu",
    "href": "posts/20240517-interesting-etymologies/etymologies.html#ordu",
    "title": "Daniel Geiszler",
    "section": "Ordu",
    "text": "Ordu\nOrdu is the Turkish word for “army”. It actually has an English cognate, “horde”! Quite a few European languages seem to have picked this word up via contact with Central Asians. The most likely source appears to be Proto-Turkic, which makes sense given the role they played in Central Asian empires. But there’s another cognate to ordu that’s even more interesting: Urdu, the national language of Pakistan. The Mughal Empire of India established Persian as the official language of the empire, and the Hindustani dialect spoken in the military camps came to be referred to as “Zaban-e-Urdu” in Persian, or “language of the army”, eventually being shortened to just “Urdu”."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/etymologies.html#rickshaw",
    "href": "posts/20240517-interesting-etymologies/etymologies.html#rickshaw",
    "title": "Daniel Geiszler",
    "section": "Rickshaw",
    "text": "Rickshaw\nRickshaws are small, hand-drawn passenger carts that were (and in some places, are) popular in Asia. It comes from the Japanese word 人力車 jinrikisha. But when it entered the English language, it actually already had a cognate, a word that came from the same root: wheel.\nFive thousand years, a group called the Yamnaya used carts and wagons on the Ukrainian Steppe. This group is generally accepted to be the source of the Indo-European Languages—a language family encompassing languages as diverse as English, Persian, and Hindi. Their word for wheel was probably something like *kʷékʷlos. This evolved over time to be something like *hwehwlą, in Proto-Germanic, the most recent common ancestor of languages like German, English, and Norwegian. This eventually became *hweōl in Old English and wheel today. That was journey that the word *kʷékʷlos took westward to arrive in English as wheel. But how did it arrive in Japanese as jinrikishaw?\nNot all of the Yamnaya people went west into Europe. Some went south into Iran and India, others went east to the edge of Mongolia. We call the earliest of these people the Afanasievo Culture, but we only know them through their archeological remains. One of the things we know about them, however, is that they used carts as early as ~3500 BCE. They are also likely to be the source of a group known as the Tocharians, that lived in the Tarim Basin in modern day Xinjiang, China. They spoke a family of languages known as Tocharian and were producing manuscripts in their languages as late as 500-800 AD. Between the Afanasievans and the Tocharians, there was almost certainly a continuous, cart-using Indo-European presence on the Chinese periphery for roughly 4000 years, a time period including the earliest known presence of wheeled vehicles in China.\nSome of these Indo-European speakers are likely the source of the Old Chinese word for wheeled vehicles, 車, which would have been pronounced *kʰlja around 1200 BC. This evolved into something like *t͡ɕʰia in Middle Chinese. That was borrowed into Japanese as 人力車 jinrikisha, or “human-power cart”, recognizably the same word we use in English today and a cognate with “wheel”."
  },
  {
    "objectID": "dashboards/20241201-training-dashboard/index.html",
    "href": "dashboards/20241201-training-dashboard/index.html",
    "title": "Training Dashboard",
    "section": "",
    "text": "This is a dashboard I made to track progress in the gym. Because this website is hosted on github-pages, which only allows static content, the dashboard itself automatically deploys on Render whenever there are updates and is embedded here in an iframe. If the formatting here is poor, it can be visited directly. Render will also shut down any apps that are inactive, so it may take a minute to start up once you open this page.\nIf you’re interested in using this yourself, just follow these steps:\n\nRecord your workouts in Google Sheets. I record my workouts here. This sheet contains the minimum columns required for the dashboard to function.\nPublish your workouts to the web. Go to File &gt; Share &gt; Publish to the web on your Google Sheet. Choose Entire Document and select Comma-separated values (.csv) as the format. Click Publish and confirm.\nWhen you open the dashboard, copy-paste your link into the data url field and click “Load Data”.\n\nFeel free to suggest features or make changes yourself. Enjoy!"
  },
  {
    "objectID": "dashboards.html",
    "href": "dashboards.html",
    "title": "Daniel Geiszler",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nTraining Dashboard\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDec 1, 2024\n\n\n1 min\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Daniel Geiszler",
    "section": "",
    "text": "Hi, I’m Danny 🧬\nI’m an EMBO Postdoctoral Fellow at Istanbul’s Koç University, trying to figure out how to maximize the PTM information we can get out of DIA data using machine learning and Bayesian statistics. My field of study is computational proteomics, with a specialization in post-translational modifications, especially open searches, glycosylation, and chemoproteomics.\nI did my Bioinformatics PhD at the University of Michigan in Alexey Nesvizhskii’s lab where I developed PTM-Shepherd and contributed to FragPipe, as well as helping in several PTM-related statistics and data science projects.\nIf you’re ever up for a friendly chat or potential collaboration, don’t hesitate to reach out."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/index.html",
    "href": "posts/20240517-interesting-etymologies/index.html",
    "title": "Interesting Etymologies Running List",
    "section": "",
    "text": "This is a running list of etymologies that I think are neat."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/index.html#temujin",
    "href": "posts/20240517-interesting-etymologies/index.html#temujin",
    "title": "Interesting Etymologies Running List",
    "section": "Temujin",
    "text": "Temujin\nGenghis Khan was just a title; his real name was Temujin. Temujin is a Mongolic name that was probably borrowed from the Proto-Turkic *temürči meaning “blacksmith”. The -ci suffix denotes a person who works with something, in this case *temür, or iron. Modern Turkish’s “demirci”, also meaning “blacksmith”, is a descendent of this word and a cognate to Temujin. These names and their friends were and are still common throughout the region. For example, Timur (also known as Tamerlame), of the Timurid Empire, shares the same root—Timur, like Turkish demir, means iron."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/index.html#ordu",
    "href": "posts/20240517-interesting-etymologies/index.html#ordu",
    "title": "Interesting Etymologies Running List",
    "section": "Ordu",
    "text": "Ordu\nOrdu is the Turkish word for “army”. It actually has an English cognate, “horde”! Quite a few European languages seem to have picked this word up via contact with Central Asians. The most likely source appears to be Proto-Turkic, which makes sense given the role they played in Central Asian empires. But there’s another cognate to ordu that’s even more interesting: Urdu, the national language of Pakistan. The Mughal Empire of India established Persian as the official language of the empire, and the Hindustani dialect spoken in the military camps came to be referred to as “Zaban-e-Urdu” in Persian, or “language of the army”, eventually being shortened to just “Urdu”."
  },
  {
    "objectID": "posts/20240517-interesting-etymologies/index.html#rickshaw",
    "href": "posts/20240517-interesting-etymologies/index.html#rickshaw",
    "title": "Interesting Etymologies Running List",
    "section": "Rickshaw",
    "text": "Rickshaw\nRickshaws are small, hand-drawn passenger carts that were (and in some places, are) popular in Asia. It comes from the Japanese word 人力車 jinrikisha. But when it entered the English language, it actually already had a cognate, a word that came from the same root: wheel.\nFive thousand years, a group called the Yamnaya used carts and wagons on the Ukrainian Steppe. This group is generally accepted to be the source of the Indo-European Languages—a language family encompassing languages as diverse as English, Persian, and Hindi. Their word for wheel was probably something like *kʷékʷlos. This evolved over time to be something like *hwehwlą, in Proto-Germanic, the most recent common ancestor of languages like German, English, and Norwegian. This eventually became *hweōl in Old English and wheel today. That was journey that the word *kʷékʷlos took westward to arrive in English as wheel. But how did it arrive in Japanese as jinrikishaw?\nNot all of the Yamnaya people went west into Europe. Some went south into Iran and India, others went east to the edge of Mongolia. We call the earliest of these people the Afanasievo Culture, but we only know them through their archeological remains. One of the things we know about them, however, is that they used carts as early as ~3500 BCE. They are also likely to be the source of a group known as the Tocharians, that lived in the Tarim Basin in modern day Xinjiang, China. They spoke a family of languages known as Tocharian and were producing manuscripts in their languages as late as 500-800 AD. Between the Afanasievans and the Tocharians, there was almost certainly a continuous, cart-using Indo-European presence on the Chinese periphery for roughly 4000 years, a time period including the earliest known presence of wheeled vehicles in China.\nSome of these Indo-European speakers are likely the source of the Old Chinese word for wheeled vehicles, 車, which would have been pronounced *kʰlja around 1200 BC. This evolved into something like *t͡ɕʰia in Middle Chinese. That was borrowed into Japanese as 人力車 jinrikisha, or “human-power cart”, recognizably the same word we use in English today and a cognate with “wheel”."
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/index.html",
    "href": "posts/20241221-rolling-blog-posts/index.html",
    "title": "Making Rolling Blog Posts",
    "section": "",
    "text": "Sometimes I stumble across something while reading and I want to be able to write and post it somewhere so that I’ll be able to access it later, but that isn’t meaningful enough to make a blog post about on its own. With this setup, I can just take a note on my phone and automatically update my blog. To do this, I use a combination of Obsidian (a notes app on my phone), Quarto (the publishing system for my personal website), and Github Actions for automatic deployment. The end result is that I can take a note on my phone in markdown format and have it automatically pushed and rendered on my website in my blog.\nThe basic workflow here is to make changes on your device in the Obsidian app, push those changes to your (private) notes repository, copy the file containing those changes to your website repository, and render them.\nYou need three things to do this: 1. The Obsidian app with the Github plugin 2. A Github repository to host your Obsidian notes (it can be private so that you can make notes without others seeing them) 3. A github repository with a Quarto project"
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/index.html#step-1-setting-up-obsidian",
    "href": "posts/20241221-rolling-blog-posts/index.html#step-1-setting-up-obsidian",
    "title": "Making Rolling Blog Posts",
    "section": "Step 1: Setting up Obsidian",
    "text": "Step 1: Setting up Obsidian\n\nDownload the Obsidian app from your mobile store\nInside Obsidian, download the Git Community plugin\nOn Github, create a Personal Access Token linked to your account. This token will need to have read/write privileges for your repository, so the “repo” box needs to be checked when setting up your token. SAVE THIS TOKEN FOR LATER.\nConfigure your Git plugin inside Obsidian to use your username, email, and your new Personal Access Token.\nLink your notes repository on Github to your Obsidian app.\n\nNow, any time you make changes to your files, you can go to the bottom right hamburger menu &gt; Open command palette &gt; Git: to commit and push your changes to your Git repository. (Note: for these commands to appear, you need to be in read mode rather than write mode, which can be toggled by clicking the book/pencil in the top right corner.)"
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/index.html#step-2-setting-up-your-rolling-blog-post",
    "href": "posts/20241221-rolling-blog-posts/index.html#step-2-setting-up-your-rolling-blog-post",
    "title": "Making Rolling Blog Posts",
    "section": "Step 2: Setting up your rolling blog post",
    "text": "Step 2: Setting up your rolling blog post\n\nIn Obsidian, create a new file, then commit your changes and push the file to your repository. 2. Verify that your file appears in your github repository after pushing. It should be a markdown file with the name {name}.md. I’m using a post title machine_learning_basics to do this, which appears as machine_learning_basics.md in my repository. If it’s there, everything is working!\nIn your Quarto site, create a new blog post. I have mine set up to have my blog posts contained inside individual directories (see my example here. To set up a new blog post, I created the folder 20241219-machine-learning-basics. Inside that folder, create the file index.qmd with the following contents (without the backslah to escape to include command}:\n\n---\ntitle: \"Machine Learning Basics\"\nauthor: \"Daniel Geiszler\"\ndate: \"2024-12-19\"\ncategories: [machine learning]\n---\n\n\\{{&lt; include machine_learning_basics.md &gt;}}\nThe first few lines are metadata for the blog post. The following statement populated the rendered blog post with the contents of another markdown file. Eventually, this markdown file will exist and be populated by your post’s content, but for now we can forget about it. However, if you want to preview your site using quarto preview to make sure it’s working, you’ll need to create an empty markdown file with the above file name in this directory."
  },
  {
    "objectID": "posts/20241221-rolling-blog-posts/index.html#step-3-set-up-github-actions-to-automatically-push-changes-to-your-website-repository",
    "href": "posts/20241221-rolling-blog-posts/index.html#step-3-set-up-github-actions-to-automatically-push-changes-to-your-website-repository",
    "title": "Making Rolling Blog Posts",
    "section": "Step 3: Set up Github actions to automatically push changes to your website repository",
    "text": "Step 3: Set up Github actions to automatically push changes to your website repository\n\nGo back to your Obsidian repository and add a repository secret. This prevents your personal access token allowing read/write access from being public and is a must for security purposes. Inside your repository, go to Settings &gt; Secrets and variables, then under Secrets add your personal access token from before as a new repository secret with the name PERSONAL_ACCESS_TOKEN.\ncreate a folder called .github/workflows if it doesn’t already exist. You may need to pull these changes to your Obsidian app before pushing any subsequent changes on your device.\nCreate a new yaml file titled something like “sync_blogpost.yml” with the following contents. You’ll need to change the fields marked with comments to match your fields. (Note: The inline comments change from # to // because some are yaml comments and some are javascript comments.)\n\nname: Sync Machine Learning Basics File # Change this to the name of your workflow\n\non:\n  push:\n    paths:\n      - 'machine_learning_basics.md'  # Watch for changes in this specific file in your notes repo\n\njobs:\n  update-file:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout source repo\n      uses: actions/checkout@v3\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16'\n\n    - name: Fetch SHA and Update File\n      uses: actions/github-script@v6\n      with:\n        github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n        script: |\n          const fs = require('fs');\n          const path = require('path');\n          const filePath = path.join(process.env.GITHUB_WORKSPACE, 'machine_learning_basics.md'); // Change this to the name of your blog post's file\n          const content = fs.readFileSync(filePath, 'utf8');\n          const encodedContent = Buffer.from(content).toString('base64');\n\n          // Fetch the current SHA of the file to be updated\n          const response = await github.rest.repos.getContent({\n            owner: 'danielgeiszler', // Change this to your github username\n            repo: 'personalwebsite', // Change this to your website's repository\n            path: 'posts/20241219-machine-learning-basics/machine_learning_basics.md', // Change this to the path inside your website repository\n            ref: 'main'  // Make sure to use the correct branch here\n          });\n\n          const sha = response.data.sha;\n\n          // Update the file with the new content and the current SHA\n          const updateResponse = await github.rest.repos.createOrUpdateFileContents({\n            owner: 'danielgeiszler', // Change this to your github username\n            repo: 'personalwebsite', // Change this to your website's repository\n            path: 'posts/20241219-machine-learning-basics/machine_learning_basics.md', // Change this to the path inside your website repository\n            message: 'Update machine learning basics', // Change this to the message displayed for your action\n            content: encodedContent,\n            sha: sha,  // Provide the SHA fetched from the previous step\n            branch: 'main',  // Make sure this is the correct branch\n            committer: {\n              name: process.env.GITHUB_ACTOR,\n              email: `${process.env.GITHUB_ACTOR}@users.noreply.github.com`\n            },\n            author: {\n              name: process.env.GITHUB_ACTOR,\n              email: `${process.env.GITHUB_ACTOR}@users.noreply.github.com`\n            }\n          });\n\n          console.log(\"File updated\", updateResponse.data);\nThat’s it! Now you can write notes on your phone and have them automatically added to your blog post."
  },
  {
    "objectID": "posts/20241219-machine-learning-basics/index.html",
    "href": "posts/20241219-machine-learning-basics/index.html",
    "title": "Machine Learning Basics",
    "section": "",
    "text": "This is a running list of machine learning architectures, terms, and concepts. I write them down here for quick reference in the future. If you see an issue, please let me know! ## Types of Learning Supervised learning: training a model on labeled pairs of input and output data to learn how to predict the output from the input\nUnsupervised learning: using unlabeled data to find patterns or clusters without having predefined labels\nSemi-supervised learning: training a model using partially labeled data, where the unlabeled data can either have labels inferred or inform the model about clusters, decision boundaries, or other properties\nOnline learning: training a model as data arrives rather than all at once, efficiently using space and allowing the model to adapt to changes over tome\nFederated learning: a distributed approach to training models where models are trained separately on different devices or datasets before being pooled\nReinforcement learning: training a model that acts as an agent and is rewarded when working properly towards a goal and punishment when not\nSelf-supervised learning: learning where the model generates its own labels from artificially constructed data\nTransfer learning: adapting a model made for one task to a new task without additional training\nFine-tuning: a type of transfer learning involving adapting a model that was previously trained on one dataset for a new purpose, training it on a smaller subset of domain-specific data, reducing the amount of time and data required to build a model"
  },
  {
    "objectID": "posts/20241219-machine-learning-basics/index.html#decision-trees",
    "href": "posts/20241219-machine-learning-basics/index.html#decision-trees",
    "title": "Machine Learning Basics",
    "section": "Decision Trees",
    "text": "Decision Trees\nDecision trees segregate data based on rules until a stopping condition is met, usually that subgroups are pure or a maximum depth is reached. Trees can predict categorical data (classification trees) and numerical data (regression trees). Advantages include fast predictions, intelligibility, and low compute requirements. Disadvantages include being prone to overfitting and instability (i.e., adding more data can cause the entire tree to be reconstructed).\nBranches are decided based on splitting criteria. Examples of splitting criteria include:\nGini impurity: measure how frequently a randomly chosen entry would be mislabeled based on the branch rule\nInformation gain: compared the entropy before and after splitting to see how much information is gained after the split\nMean squared error (regression trees): rules are chosen minimize variance in predicted values\nTrees can be “regularized” via pruning to prevent overfitting. This can happen in two ways:\nPre-pruning (early stopping): preventing new branches from being formed after a certain threshold or depth\nPost-pruning (cost-complexity pruning): post-box removal of branches that don’t produce any gains in validation data\n\nRandom Forests\nRandom forests solve a single decision tree’s problem with overfitting by producing an ensemble of decision trees. Decision trees are fit for random subsets of the data, then averaged (regression) or vote on the outcome (classification) during prediction. The process of averaging trees that are trained in parallel is called “bagging”.\n\n\nBoosted Trees\nBoosted trees compensate for the weakness of an initial tree by building sequential trees to correct errors in previous trees. The process of averaging trees that are trained sequentially is called boosting. Some key algorithms related to boosting:\nAdaBoost: increases the weight of incorrectly predicted data in subsequent trees\nGradient boosting: a specific type of boosting where a differentiable loss function is used to fit sequential models on the residuals of the previous model\nXGBoost: a popular library implementing gradient-boosted decision trees that is optimized for efficiency"
  },
  {
    "objectID": "posts/20241219-machine-learning-basics/index.html#regularization",
    "href": "posts/20241219-machine-learning-basics/index.html#regularization",
    "title": "Machine Learning Basics",
    "section": "Regularization",
    "text": "Regularization\nRegularization is the process by which we penalize model complexity, done to reduce overfitting and make models more generalizable. This can be split into two broad categories, explicit regularization—where a regularizing term, be it a penalty, prior, or constraint, is added to directly the optimization problem, and implicit regularization, which broadly encompasses other methods of preventing overfitting.\nThese are some of the most commonly types of explicit regularization:\nLasso (L1 regularization): adds a penalty proportional to the absolute values of the model parameters, making some parameters go to zero (get dropped out) during optimization. It can be used to perform feature selection if you suspect there are irrelevant variables.\nRidge regression (L2 regularization): adds a penalty proportional to the sum of squares of the model parameters, shrinking their coefficients to zero but generally without dropping them out of the optimization altogether. It can be used to reduce the weights of highly correlated variables in tandem, whereas L1 regularization might select a single feature and drop the others. It is generally more stable than L1 regularization because it doesn’t remove parameters.\nElastic Net: combines L1 and L2 regularization, simultaneously shrinking coefficients while performing feature selection. The relative weight of the L1 and L2 contributions to regularization are controlled by the \\(\\alpha\\) parameter.\n\nDeep Learning\nDeep learning uses multi-layer neural networks to learn representations from data. Each layer is made up of neurons which activate under simple activation functions. Differences in deep learning modalities can arise from differences in activation functions or neuron connectivity."
  },
  {
    "objectID": "posts/20241215-testing-pyro/testing_pyro.html",
    "href": "posts/20241215-testing-pyro/testing_pyro.html",
    "title": "Learning Pyro for Better Content Sorting",
    "section": "",
    "text": "I’ve been looking for a reason to learn to use the Pyro library in Python for Markov Chain Monte Carlo (MCMC) simulations, and I’ve finally found one. This is me documenting how to learn to use it for future reference, and hopefully you’ll be able to get something out of it too.\nHave you ever sorted content on a website by “Top Ranked” or something similar, only do be inundated with a bunch of posts with a 100% rating but only a tiny number of reviews? It can make it frustrating or impossible to find “the best” of something when it’s hiding below hundreds or thousands of other things. If you’re going to rank by the average score for a piece of content, it’s inevitable that you’ll end up with some items near the top of the list that shouldn’t be. This happens because low sample sizes (e.g., a small number of reviews or upvotes) lead to a wide variety of estimates of the content’s “true” rating.\nThankfully, lots of smart companies have come up with better ways to rank their content! Reddit, for example, used to use a confidence interval around the score of the of a post (see the cpdef double _confidence function) to account for uncertainty in its “true” score. This has the effect of penalizing upvoted posts that have a low score with only a handful of upvotes, but it will also boost downvoted posts in the same situation. As the number of votes increases, the confidence in the post’s true rating also increases.\nOther companies seem to have an issue with this. For example, Google Maps has pretty limited options on what you can sort by, and instead only allows you to filter based on certain ranges of average review score. This still leaves the top results polluted by new, fake, or closed restaurants when you’re going out to eat. This isn’t a good system, and I frequently find myself with bad results. You have to go to an entirely different website to get decent results.\nFinding a better estimate of a restaurant’s “true rating” is a good use case for Pyro, a probabilistic programming language thats uses PyTorch. Pyro make it easy to find a restaurant’s “true rating” (posterior probability) given its current ratings (likelihood) and some assumptions about what its true rating is likely to be before any reviews are given (prior probability). These problems can be solved using MCMC simulations to estimate the posterior probability. PyTorch is supposed to make these sorts of problems easy, so I’m going to use it to estimate the posterior probabilities of some content and learn how to use Pyro along the way.\nInstalling PyTorch isn’t as simple as most other python packages, so I recommend looking at their website to do it (https://pytorch.org/). Beyond that, you’ll also need pandas and the pyro package (https://pyro.ai/).\n\n# import packages\n\nimport torch\nimport pyro\nimport pyro.distributions as dist\nimport pandas as pd\n\nfrom pyro.infer import MCMC, NUTS, SVI, Trace_ELBO\nfrom pyro.optim import Adam\n\nIf you installed PyTorch correctly and you have an nVidia GPU, you can run this to see if your GPU is available for PyTorch to use. This workbook should still work even if this isn’t true, instead running the simulations on your CPU. The first few will run on the default device, but I’ll switch to my GPU later.\n\nif torch.cuda.is_available():\n    print(\"CUDA is available. GPU is ready to be used.\")\nelse:\n    print(\"CUDA is not available. Running on CPU.\")\n\nCUDA is available. GPU is ready to be used.\n\n\nAs a toy example, let’s consider a restaurant or some other piece of content that has a single upvote in an upvote/downvote rating system. This will run on the default device regardless of your GPU setup.\n\n# Data: 1 thumb up out of 1 observation\ndata = torch.tensor([1.])\n\nWe first need to define a model that PyTorch will simulate.\n\nThe pyro.sample function here is given two arguments: the name of your sample and the prior distribution. In this case, we use the Beta(1,1) distribution as our prior. This draws a sample from the Beta(1,1) distribution for our prior. The beta distribution is a common prior when estimating probabilities because of both the posterior and the prior are defined over [0,1]. It is also a conjugate prior for the Binomial distribution, which is the distribution for a series of up-down votes. The Beta(1,1) is a uniform distribution, which indicates we have no information about the prior probability. In practice, Betas tend to be used more than Uniforms due to their flexibility, but the results should be the same regardless. It is also easy to interpret in our case because the Beta(a,b) parameters a and b correspond to pseudocounts for upvotes and downvotes for our content. This will come in handy later.\nThe pyro.plate function indicates that all of the observations are IID, and again takes two arguments: a name and the number of observations. We then use the pyro.sample function again, but this time the probability of success (in this case, an upvoted restaurants) is given by the the probability from the first step, and our observed data is used as our evidence.\n\n\n# Define the model\ndef beta_model(data):\n    # Prior distribution for the probability of a thumb up\n    prob_thumb_up = pyro.sample(\"prob_thumb_up\", dist.Beta(1, 1))\n    # Observing the data\n    with pyro.plate(\"data\", len(data)):\n        pyro.sample(\"obs\", dist.Bernoulli(prob_thumb_up), obs=data)\n\nTo simulate our posterior, we use NUTS (No U-turn Sampler). We then run our MCMC method to extract all of the posterior simulations. The NUTS sampler starts off slow and not giving useful information at the beginning, so we throw out the first warmup_steps.\n\n# Run sampling\nnuts_kernel = NUTS(beta_model)\nmcmc = MCMC(nuts_kernel, num_samples=100, warmup_steps=200)\nmcmc.run(data)\n\nSample: 100%|██████████| 300/300 [00:00, 315.72it/s, step size=1.05e+00, acc. prob=0.872]\n\n\nNow that our 100 samples have run in ~1 second, we can see what our posterior distribution looks like.\n\n# Extract samples\nsamples = mcmc.get_samples()\nprob_thumb_up_samples = samples['prob_thumb_up']\nprint(samples)\n\n# Make histogram of samples\nsamples_df = pd.DataFrame(samples)\nsamples_df.hist()\n\n{'prob_thumb_up': tensor([0.9948, 0.9911, 0.9932, 0.8157, 0.9069, 0.9725, 0.9605, 0.7183, 0.6688,\n        0.4664, 0.4664, 0.1412, 0.4164, 0.4164, 0.4718, 0.4669, 0.1655, 0.1651,\n        0.9353, 0.9179, 0.9453, 0.6563, 0.9291, 0.9523, 0.9919, 0.9892, 0.8332,\n        0.8525, 0.7400, 0.7400, 0.8004, 0.8386, 0.8639, 0.8639, 0.8468, 0.9864,\n        0.7228, 0.2010, 0.8474, 0.6574, 0.6523, 0.6671, 0.6671, 0.7251, 0.8520,\n        0.8915, 0.2909, 0.4525, 0.2638, 0.4680, 0.5942, 0.3475, 0.3475, 0.8394,\n        0.8396, 0.7719, 0.7719, 0.3881, 0.3250, 0.5279, 0.6887, 0.0769, 0.9948,\n        0.9938, 0.9592, 0.9085, 0.1504, 0.9345, 0.5709, 0.4091, 0.6242, 0.9275,\n        0.1048, 0.9889, 0.9549, 0.9138, 0.7142, 0.7142, 0.8877, 0.8169, 0.8869,\n        0.7573, 0.7573, 0.8330, 0.7542, 0.8275, 0.6461, 0.6482, 0.6646, 0.6646,\n        0.5550, 0.5550, 0.7538, 0.5528, 0.1494, 0.4221, 0.8125, 0.7165, 0.3323,\n        0.6686])}\n\n\narray([[&lt;Axes: title={'center': 'prob_thumb_up'}&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\nOur probability distribution looks like it’s multimodal, when it should be unimodal. That probably means the model didn’t converge. Let’s try upping the number of samples we use to see if we can get a better behaved distribution.\n\n# Run sampling\nnuts_kernel = NUTS(beta_model)\nmcmc = MCMC(nuts_kernel, num_samples=10000, warmup_steps=200)\nmcmc.run(data)\n\n# Extract samples\nsamples = mcmc.get_samples()\nprob_thumb_up_samples = samples['prob_thumb_up']\nprint(samples)\n\n# Make histogram of samples\nsamples_df = pd.DataFrame(samples)\nsamples_df.hist()\n\nSample: 100%|██████████| 10200/10200 [00:28, 357.90it/s, step size=6.56e-01, acc. prob=0.898]\n\n\n{'prob_thumb_up': tensor([0.5870, 0.4914, 0.8957,  ..., 0.2461, 0.5114, 0.9622])}\n\n\n\n\n\narray([[&lt;Axes: title={'center': 'prob_thumb_up'}&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\nThis distribution looks much more regular. From this, we can calculate the confidence interval for our restaurant’s “true rating”.\n\n# Compute confidence interval\nconfidence_interval = torch.quantile(prob_thumb_up_samples, torch.tensor([0.025, 0.975]))\n\nprint(f\"Estimated probability of thumb up: {prob_thumb_up_samples.mean().item():.4f}\")\nprint(f\"95% confidence interval: {confidence_interval.tolist()}\")\n\nEstimated probability of thumb up: 0.6559\n95% confidence interval: [0.1598558872938156, 0.9852998852729797]\n\n\nWe should also probably check to make sure that our estimates are valid. This particular example is trivial because of our choice of distribution and prior. Because we used a conjugate prior (Beta) for our observed data (Binomial/Bernoulli), we have a closed form solution for our expected result. I mentioned before that the a and b parameters for the Beta(a,b) distribution are pseudocounts for successes (thumbs up) and failures (thumbs down), respectively. That means that if our prior distribution has the form Beta(1,1) and we have observed 1 additional success, our posterior distribution has the form Beta(2,1).\nYou can see slide 12 of David Maracek’s excellent lecture on Beta-Bernoulli distributions to see what this looks like, or you can draw the Beta(2,1) distribution yourself using this applet.\nThe shape of our simulated posterior looks almost exactly like our expected output. Success!\nHow a content rating system wants to use this information would be up to them. In Reddit’s case, it looks like they used an 80% bound to rank their posts. If you want your ranking to be much stricter, you could use the lower bound of the credible interval, which would push new entries to the bottom of the ranking. You could also increase the number of pseudocounts in your Beta prior to something like the mean value of upvotes and downvotes, which may be more appropriate if you want new content to be ranked “average” until proven otherwise.\nIn some cases, it may be more appropriate to do this in a regression framework so that you can control for other variables. I’m going to repeat this analysis using logistic regression, which models the log-odds of a success. I’ll also do it on the GPU (although for small samples and simple models this may not be necessary due to the overhead incurred by moving data to your GPU).\nFirst we’ll check to see if we can use our GPU. If we can, we’ll create our data on our GPU. All of the data needs to be in one place for this to work and it will default to your CPU, so you’ll need to explicitly put everything on your GPU. A GPU will actually be a bit slower for this use case due to the overhead incurred, but it’s a good reference for larger models.\n\n# Check for CUDA availability and prepare data\nif torch.cuda.is_available():\n    device = torch.device(\"cuda\")\n    # Create data tensor on GPU\n    data = torch.tensor([1.]).to(device)\n    print(\"Data moved to GPU.\")\nelse:\n    device = torch.device(\"cpu\")\n    data = torch.tensor([1.]).to(device)\n    print(\"CUDA not available, running on CPU.\")\n    \n# Validate devices\ntorch.cuda.get_device_name(torch.cuda.current_device())\n\nData moved to GPU.\n\n\n'NVIDIA GeForce RTX 3050 Laptop GPU'\n\n\nNext we’ll define our model. This model is going to look different from the previous one. In our logistic regression, the intercept will give us the log-odds of our restaurant’s true probability of thumbs up. This parameter is no longer bounded on [0,1], which means the Beta distribution is no longer appropriate. There are a few options here. * A normal distribution with mean 0 (p = 0.5 means the odds are (0.5) / (1 - 0.5) = 1, and log(1) = 0. This is a common choice, but choosing the variance is tricky because there is no closed form solution, so we would have to pick one based on how informative we want it to be. * A Cauchy distribution with mean 0 (for the same reason) and scale 2.5. This is based on the recommendation of Gelman et al (2008) (http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf). There is still no way to properly estimate the variance of the intercept, so our choice is again going to affect our outcomes.\n\ndef logistic_model(data):  \n    # Create parameters for the distribution on the correct device\n    mean = torch.tensor(0., device=device)  # Ensure mean is a tensor on GPU\n    scale = torch.tensor(2.5, device=device)  # Ensure standard deviation is a tensor on GPU\n    \n    # Create the Cauchy distribution with parameters on the correct device\n    prior_dist = dist.Cauchy(mean, scale)\n    \n    # Sample intercept from the distribution\n    intercept = pyro.sample(\"intercept\", prior_dist)\n    \n    # Observing the data with Bernoulli likelihood\n    with pyro.plate(\"data_plate\", len(data)):\n        pyro.sample(\"obs\", dist.Bernoulli(logits=intercept), obs=data)\n\nThen we repeat our sampling. I repeated this a few times before settling on 2000 samples for decent convergence.\n\n#NUTS sampler\nnuts_kernel = NUTS(logistic_model)\nmcmc = MCMC(nuts_kernel, num_samples=2000, warmup_steps=200)\nmcmc.run(data)\n\nSample: 100%|██████████| 2200/2200 [00:40, 54.64it/s, step size=1.72e-01, acc. prob=0.923] \n\n\nAnd again check our model convergence. To plot these, we’ll also need to transfer these back to our CPU. We expect a normal distribution for the intercept parameter if the model converged. There are better ways to check the convergence such as Effective Sample Size (ESS) or Gelman-Rubin convergence, but they require running multiple chains which is finnicky on Windows.\n\n# Check model convergence\nintercept_df = pd.DataFrame({'intercept' : mcmc.get_samples()['intercept'].to('cpu')})\nintercept_df.hist()\n\narray([[&lt;Axes: title={'center': 'intercept'}&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\nThat doesn’t look very normal! Probably because we only have one sample. It’s possible that a distribution with smaller tails, like the normal, will work better here. Let’s try again with the normal distribution.\n\ndef logistic_model(data):  \n    # Create parameters for the distribution on the correct device\n    mean = torch.tensor(0., device=device)  # Ensure mean is a tensor on GPU\n    scale = torch.tensor(2.5, device=device)  # Ensure standard deviation is a tensor on GPU\n    \n    # Create the Normal distribution with parameters on the correct device\n    prior_dist = dist.Normal(mean, scale)\n    \n    # Sample intercept from the distribution\n    intercept = pyro.sample(\"intercept\", prior_dist)\n    \n    # Observing the data with Bernoulli likelihood\n    with pyro.plate(\"data_plate\", len(data)):\n        pyro.sample(\"obs\", dist.Bernoulli(logits=intercept), obs=data)\n\n\n#NUTS sampler\nnuts_kernel = NUTS(logistic_model)\nmcmc = MCMC(nuts_kernel, num_samples=2000, warmup_steps=200)\nmcmc.run(data)\n\nSample: 100%|██████████| 2200/2200 [00:19, 112.19it/s, step size=1.21e+00, acc. prob=0.923]\n\n\n\n# Check model convergence\nintercept_df = pd.DataFrame({'intercept' : mcmc.get_samples()['intercept'].to('cpu')})\nintercept_df.hist()\n\narray([[&lt;Axes: title={'center': 'intercept'}&gt;]], dtype=object)\n\n\n\n\n\n\n\n\n\nThat looks pretty normal now. We’ll need to turn these back into probabilities using the signmoid function.\n\n# Extract samples\nsamples = mcmc.get_samples()['intercept'].to('cpu')\n\n# Plot probabilities\ninferred_probs_df = pd.DataFrame({'probs' : torch.sigmoid(samples)})\ninferred_probs_df.hist()\n\n\ninferred_prob = torch.sigmoid(samples).mean().item()\n\nprint(f\"Inferred probability of a thumb up: {inferred_prob:.4f}\")\n\n# Compute confidence interval\nconfidence_interval_vals = torch.quantile(samples, torch.tensor([0.025, 0.975]))\nconfidence_interval = torch.sigmoid(confidence_interval_vals)\nprint(f\"95% confidence interval: {confidence_interval.tolist()}\")\n\nInferred probability of a thumb up: 0.7413\n95% confidence interval: [0.1398516297340393, 0.9961099028587341]\n\n\n\n\n\n\n\n\n\nOur original estimate using the beta distribution was 0.6649 with a 95% confidence interval: [0.1617867797613144, 0.9869610667228699]. That’s a bit different from this, but the choice of prior influences the outcome. Overall though, that looks like a pretty good estimate of the analytical solution despite only having a single sample.\nWhat happens if we increased the number of samples to 100? How accurate can we get with a moderate amount of data? Let’s say we want to model something with a 90% upvote rate, so 90 thumbs up and 10 thumbs down.\n\n# Data: 90 thumbs up, 10 thumbs down\ndata = torch.cat((torch.ones(90), torch.zeros(10)))\n\n# Rerun model with reduced steps\nnuts_kernel = NUTS(beta_model)\nmcmc = MCMC(nuts_kernel, num_samples=2000, warmup_steps=200)\nmcmc.run(data)\n\n# Extract samples\nsamples = mcmc.get_samples()\nprob_thumb_up_samples = samples['prob_thumb_up']\n\n# Make histogram of samples\nsamples_df = pd.DataFrame(samples)\nsamples_df.hist()\n\n# Compute confidence interval\nconfidence_interval = torch.quantile(prob_thumb_up_samples, torch.tensor([0.025, 0.975]))\n\nprint(f\"Estimated probability of thumb up: {prob_thumb_up_samples.mean().item():.4f}\")\nprint(f\"95% confidence interval: {confidence_interval.tolist()}\")\n\nSample: 100%|██████████| 2200/2200 [00:06, 358.01it/s, step size=1.25e+00, acc. prob=0.899]\n\n\nEstimated probability of thumb up: 0.8920\n95% confidence interval: [0.8236452341079712, 0.9434589743614197]\n\n\n\n\n\n\n\n\n\nAn estimate of 0.89 for a 90% upvoted piece of content is pretty good, and the spread on the estimate is much tighter than before.\nThis is still a really simple model, though. For more complicated models, MCMC might be prohibitively slow. For real life scenarios, it’s inlikely to be doing something with this few samples and this simple of a model. In these cases, you might want to try variational inference (VI) instead of MCMC. VI allows you to turn the sampling problem into an optimization problem, where you optimize the parameters of a distirbution directly. Here I’m going to use the Adam optimizer, which is short for adaptive gradient descent. It’s popular in lots of mcahine learning applications due to its speed and ability to handle sparse gradients. We can check to see how well Adam is optimizing by checking to see if the evidence lower bound (ELBO) converges. We can pump up our data a bit, too.\n\n# Define the guide (variational posterior)\ndef guide(data):\n    # Variational parameters for the intercept\n    mean_q = pyro.param(\"mean_q\", torch.tensor(0.0, device=device))\n    scale_q = pyro.param(\"scale_q\", torch.tensor(1.0, device=device), constraint=dist.constraints.positive)\n    \n    pyro.sample(\"intercept\", dist.Normal(mean_q, scale_q))\n\n# Data: 900 thumbs up, 100 thumbs down, and make sure its in the right place\ndata = torch.cat((torch.ones(900), torch.zeros(100))).to(device)\n\n# Set up the optimizer and inference algorithm\noptimizer = Adam({\"lr\": torch.tensor(0.001, device=device)})  # Learning rate\nsvi = SVI(logistic_model, guide, optimizer, loss=Trace_ELBO())\n\n# Perform optimization\nnum_steps = 10000\nlosses = []\nfor step in range(num_steps):\n    loss = svi.step(data)  # Perform one step of optimization\n    losses.append(loss)\n    if step % 1000 == 0:\n        print(f\"Step {step} - Loss: {loss}\")\n\n# Inspect learned parameters\nmean_q = pyro.param(\"mean_q\").item()\nscale_q = pyro.param(\"scale_q\").item()\nprint(f\"Posterior Mean: {mean_q}, Posterior Std: {scale_q}\")\n\n# Plot ELBO convergence\nimport matplotlib.pyplot as plt\nplt.plot(losses)\nplt.xlabel(\"Iteration\")\nplt.ylabel(\"ELBO Loss\")\nplt.title(\"ELBO Convergence\")\nplt.show()\n\nStep 0 - Loss: 641.3312163352966\nStep 1000 - Loss: 543.6905220746994\nStep 2000 - Loss: 568.6181250810623\nStep 3000 - Loss: 474.34459149837494\nStep 4000 - Loss: 342.52564430236816\nStep 5000 - Loss: 355.2464487552643\nStep 6000 - Loss: 343.4673839211464\nStep 7000 - Loss: 339.71015548706055\nStep 8000 - Loss: 327.89236748218536\nStep 9000 - Loss: 330.6277858018875\nPosterior Mean: 2.189785957336426, Posterior Std: 0.15260715782642365\n\n\n\n\n\n\n\n\n\nThat elbow plot clearly converges, so it looks like the optimizer worked well. All that’s left is seeing if the estimate we got for the posterior probability of the intercept is accurate. To do that, we’ll need to transform our log odds back into a probability of thumbs up.\n\nimport math\n\n# Convert posterior mean (log-odds) to probability\nposterior_mean = pyro.param(\"mean_q\").item()\n\n# Probability from logistic function\nposterior_probability = 1 / (1 + math.exp(-posterior_mean))\n\nprint(posterior_probability)\n\n0.8993285293702843\n\n\nA perfect estimate!"
  }
]